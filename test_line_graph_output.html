<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>karana LineGraph</title>
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #1f2933;
      background: #f9fafb;
    }
    body {
      margin: 0;
      padding: 1.5rem;
    }
    .karana-container {
      max-width: 960px;
      margin: 0 auto;
      background: #ffffff;
      border-radius: 12px;
      box-shadow: 0 14px 30px rgba(15, 23, 42, 0.08);
      padding: 1.5rem 1.75rem 2rem;
    }
    h1 {
      font-size: 1.5rem;
      margin: 0 0 1rem;
    }
    .controls {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }
    .control-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
    }
    label {
      font-weight: 600;
      font-size: 0.95rem;
      min-width: 120px;
    }
    select, input[type="text"] {
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      border: 1px solid #cbd5e1;
      font-size: 0.95rem;
      min-width: 220px;
      background: #f8fafc;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    select:focus, input[type="text"]:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15);
      background: white;
    }
    button {
      border: none;
      background: #2563eb;
      color: white;
      border-radius: 999px;
      padding: 0.45rem 0.9rem;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background 0.2s ease, box-shadow 0.2s ease;
    }
    button:hover {
      background: #1d4ed8;
      box-shadow: 0 10px 20px rgba(37, 99, 235, 0.2);
    }
    .region-slot {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .region-slot span {
      font-weight: 600;
      color: #475569;
      min-width: 1.5rem;
      text-align: right;
    }
    .status-message {
      min-height: 1.25rem;
      font-size: 0.9rem;
      color: #dc2626;
    }
    #chart {
      width: 100%;
      min-height: 420px;
    }
  </style>
</head>
<body>
  <div class="karana-container">
    <h1>karana LineGraph</h1>
    <div class="controls">
      <div class="control-group">
        <label for="dataset-select">Dataset</label>
        <select id="dataset-select"></select>
      </div>
      <div class="control-group">
        <label>Series</label>
        <div id="region-selects" class="region-list"></div>
        <button id="add-region" type="button">+ Add Series</button>
      </div>
      <div class="control-group">
        <label for="expression-input">Expression</label>
        <input id="expression-input" type="text" placeholder="e.g. 1/(1+2)" />
      </div>
      <div class="status-message" id="status-message"></div>
    </div>
    <div id="chart"></div>
  </div>

  <script>
    const payload = {"datasets": {"gdp_ppp": {"years": ["2018", "2019", "2020"], "regions": {"India": [90.0, 100.0, 110.0], "World": [180.0, 200.0, 220.0], "China": [120.0, 140.0, 160.0]}}}, "defaults": {"dataset": "gdp_ppp", "seriesNames": ["India", "World"], "expression": "1 / 2"}};

    const state = {
      datasetKey: payload.defaults.dataset,
      regionNames: [...payload.defaults.seriesNames],
      expression: payload.defaults.expression,
    };

    const datasetSelect = document.getElementById("dataset-select");
    const regionContainer = document.getElementById("region-selects");
    const addRegionButton = document.getElementById("add-region");
    const expressionInput = document.getElementById("expression-input");
    const statusMessage = document.getElementById("status-message");

    function getDataset(key) {
      return payload.datasets[key];
    }

    function ensureRegionSelectionsAvailable(dataset) {
      const available = Object.keys(dataset.regions);
      if (available.length === 0) {
        throw new Error("Dataset '" + state.datasetKey + "' has no region data.");
      }
      state.regionNames = state.regionNames.map((name, index) => {
        if (available.includes(name)) {
          return name;
        }
        return available[Math.min(index, available.length - 1)];
      });
      if (state.regionNames.length === 0) {
        state.regionNames = [available[0]];
      }
    }

    function buildDatasetSelect() {
      const options = Object.keys(payload.datasets)
        .map((key) => {
          const selected = key === state.datasetKey ? "selected" : "";
          return `<option value="${key}" ${selected}>${key}</option>`;
        })
        .join("");
      datasetSelect.innerHTML = options;
      datasetSelect.value = state.datasetKey;
    }

    function buildRegionControls() {
      regionContainer.innerHTML = "";
      const dataset = getDataset(state.datasetKey);
      const available = Object.keys(dataset.regions);

      state.regionNames.forEach((regionName, idx) => {
        const slot = document.createElement("div");
        slot.className = "region-slot";

        const label = document.createElement("span");
        label.textContent = idx + 1;
        slot.appendChild(label);

        const select = document.createElement("select");
        available.forEach((name) => {
          const option = document.createElement("option");
          option.value = name;
          option.textContent = name;
          if (name === regionName) {
            option.selected = true;
          }
          select.appendChild(option);
        });

        select.addEventListener("change", () => {
          state.regionNames[idx] = select.value;
          updateChart();
        });

        slot.appendChild(select);
        regionContainer.appendChild(slot);
      });
    }

    function addRegionSlot() {
      const dataset = getDataset(state.datasetKey);
      const available = Object.keys(dataset.regions);
      if (available.length === 0) {
        statusMessage.textContent = "Cannot add series: dataset has no regions.";
        return;
      }
      const unused = available.find((name) => !state.regionNames.includes(name));
      state.regionNames.push(unused || available[0]);
      buildRegionControls();
    }

    function tokenize(expression) {
      const tokens = [];
      let i = 0;
      while (i < expression.length) {
        const ch = expression[i];
        if (ch === " " || ch === "\t" || ch === "\n") {
          i += 1;
          continue;
        }
        if ("+-*/()".includes(ch)) {
          tokens.push(ch);
          i += 1;
          continue;
        }
        if ((ch >= "0" && ch <= "9") || ch === ".") {
          let value = ch;
          i += 1;
          while (i < expression.length) {
            const next = expression[i];
            if ((next >= "0" && next <= "9") || next === ".") {
              value += next;
              i += 1;
            } else {
              break;
            }
          }
          tokens.push(value);
          continue;
        }
        throw new Error("Unexpected character '" + ch + "' in expression.");
      }
      return tokens;
    }

    function shuntingYard(tokens, regionCount) {
      const output = [];
      const operators = [];
      const precedence = {
        "+": 1,
        "-": 1,
        "*": 2,
        "/": 2,
        "u-": 3,
      };
      const associativity = {
        "+": "L",
        "-": "L",
        "*": "L",
        "/": "L",
        "u-": "R",
      };
      let expectOperand = true;

      for (const token of tokens) {
        if (token === "(") {
          operators.push(token);
          expectOperand = true;
          continue;
        }
        if (token === ")") {
          while (operators.length > 0 && operators[operators.length - 1] !== "(") {
            output.push(operators.pop());
          }
          if (operators.length === 0) {
            throw new Error("Mismatched parentheses in expression.");
          }
          operators.pop();
          expectOperand = false;
          continue;
        }
        if ("+-*/".includes(token)) {
          if (token === "-" && expectOperand) {
            operators.push("u-");
            continue;
          }
          while (operators.length > 0) {
            const top = operators[operators.length - 1];
            if (top === "(") {
              break;
            }
            const topPrec = precedence[top];
            const tokenPrec = precedence[token];
            if (
              topPrec > tokenPrec ||
              (topPrec === tokenPrec && associativity[token] === "L")
            ) {
              output.push(operators.pop());
            } else {
              break;
            }
          }
          operators.push(token);
          expectOperand = true;
          continue;
        }
        // number literal (potentially region reference)
        const numeric = Number(token);
        if (Number.isNaN(numeric)) {
          throw new Error("Invalid number token '" + token + "'.");
        }
        if (!token.includes(".") && numeric >= 1 && numeric <= regionCount) {
          output.push({ type: "region", index: numeric - 1 });
        } else {
          output.push({ type: "literal", value: numeric });
        }
        expectOperand = false;
      }

      while (operators.length > 0) {
        const op = operators.pop();
        if (op === "(" || op === ")") {
          throw new Error("Mismatched parentheses in expression.");
        }
        output.push(op);
      }

      return output;
    }

    function toArray(value, length) {
      if (Array.isArray(value)) {
        return value.slice();
      }
      const arr = new Array(length);
      for (let i = 0; i < length; i += 1) {
        arr[i] = value;
      }
      return arr;
    }

    function evaluateExpression(expression, regionSeries, yearsCount) {
      const tokens = tokenize(expression);
      const rpn = shuntingYard(tokens, regionSeries.length);
      const stack = [];

      for (const token of rpn) {
        if (typeof token === "string") {
          if (token === "u-") {
            if (stack.length < 1) {
              throw new Error("Invalid expression: unary operator missing operand.");
            }
            const value = stack.pop();
            const array = toArray(value, yearsCount);
            stack.push(array.map((v) => (v == null ? null : -v)));
            continue;
          }
          if (stack.length < 2) {
            throw new Error("Invalid expression: binary operator missing operands.");
          }
          const right = stack.pop();
          const left = stack.pop();
          const leftArr = toArray(left, yearsCount);
          const rightArr = toArray(right, yearsCount);
          const result = new Array(yearsCount);
          for (let i = 0; i < yearsCount; i += 1) {
            const lv = leftArr[i];
            const rv = rightArr[i];
            if (lv == null || rv == null) {
              result[i] = null;
              continue;
            }
            switch (token) {
              case "+":
                result[i] = lv + rv;
                break;
              case "-":
                result[i] = lv - rv;
                break;
              case "*":
                result[i] = lv * rv;
                break;
              case "/":
                result[i] = rv === 0 ? null : lv / rv;
                break;
              default:
                throw new Error("Unsupported operator '" + token + "'.");
            }
          }
          stack.push(result);
          continue;
        }
        if (token.type === "region") {
          const idx = token.index;
          if (idx < 0 || idx >= regionSeries.length) {
            throw new Error("Expression references series #" + (idx + 1) + " which is undefined.");
          }
          stack.push(regionSeries[idx].values);
          continue;
        }
        if (token.type === "literal") {
          stack.push(token.value);
          continue;
        }
        throw new Error("Unknown token in evaluation.");
      }

      if (stack.length !== 1) {
        throw new Error("Invalid expression: leftover values after evaluation.");
      }

      return toArray(stack[0], yearsCount);
    }

    function updateChart() {
      try {
        statusMessage.textContent = "";
        const dataset = getDataset(state.datasetKey);
        ensureRegionSelectionsAvailable(dataset);
        buildRegionControls();

        const years = dataset.years;
        const regionSeries = state.regionNames.map((name, idx) => {
          const values = dataset.regions[name];
          if (!values) {
            throw new Error("Region '" + name + "' not available in dataset.");
          }
          return {
            index: idx,
            name,
            values,
          };
        });

        const expressionValues = evaluateExpression(
          state.expression,
          regionSeries,
          years.length
        );

        const traces = [];
        regionSeries.forEach((series, idx) => {
          traces.push({
            x: years,
            y: series.values,
            mode: "lines",
            name: `${idx + 1} = ${series.name}`,
            line: {
              width: 1.5,
              dash: "dot",
            },
            hovertemplate: `%{x}<br>${series.name}: %{y}<extra></extra>`,
          });
        });

        traces.push({
          x: years,
          y: expressionValues,
          mode: "lines",
          name: "Expression",
          line: {
            width: 3,
            color: "#1d4ed8",
          },
          hovertemplate: `%{x}<br>Expression: %{y}<extra></extra>`,
        });

        Plotly.react("chart", traces, {
          margin: { l: 60, r: 30, t: 20, b: 60 },
          hovermode: "x unified",
          legend: { orientation: "h", y: -0.2 },
          xaxis: { title: "Year" },
          yaxis: { title: "Value" },
        });
      } catch (error) {
        statusMessage.textContent = error.message;
        Plotly.purge("chart");
      }
    }

    datasetSelect.addEventListener("change", () => {
      state.datasetKey = datasetSelect.value;
      const dataset = getDataset(state.datasetKey);
      ensureRegionSelectionsAvailable(dataset);
      buildRegionControls();
      updateChart();
    });

    addRegionButton.addEventListener("click", () => {
      addRegionSlot();
      updateChart();
    });

    expressionInput.addEventListener("input", () => {
      state.expression = expressionInput.value;
      updateChart();
    });

    function init() {
      buildDatasetSelect();
      const dataset = getDataset(state.datasetKey);
      ensureRegionSelectionsAvailable(dataset);
      buildRegionControls();
      expressionInput.value = state.expression;
      updateChart();
    }

    init();
  </script>
</body>
</html>
